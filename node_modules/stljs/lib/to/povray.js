// Generated by CoffeeScript 1.6.3
(function() {
  var Stl, stl_parser;

  stl_parser = require('../parser/stl_parser');

  Stl = (function() {
    function Stl() {}

    return Stl;

  })();

  Stl.PovRay = (function() {
    function PovRay() {}

    PovRay.prototype._povHeaders = function(name) {
      return "#declare " + name + " = mesh {\n";
    };

    PovRay.prototype._povFooters = function() {
      return "}";
    };

    PovRay.prototype.convertFile = function(filePath, callback, progressCb) {
      var output,
        _this = this;
      output = "";
      return stl_parser.parseFile(filePath, function(err, polygons, name) {
        var unique_name;
        if (err != null) {
          callback(err);
          return;
        }
        unique_name = '__' + name + '__';
        output += _this._povFooters();
        return callback(null, output, unique_name);
      }, function(err, polygon, name) {
        var povPolygon, unique_name;
        unique_name = '__' + name + '__';
        if (output.length === 0) {
          output += _this._povHeaders(unique_name);
        }
        povPolygon = _this.convertPolygon(polygon);
        output += povPolygon;
        if (progressCb != null) {
          return progressCb(err, povPolygon, unique_name);
        }
      });
    };

    PovRay.prototype.convertPolygon = function(polygon) {
      var idx, output, vertex, _i, _len, _ref;
      output = "";
      output += "  triangle {\n";
      _ref = polygon.verticies;
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        vertex = _ref[idx];
        output += "    <" + vertex[0] + ", " + (-vertex[1]) + ", " + vertex[2] + ">";
        if (idx !== (polygon.verticies.length - 1)) {
          output += ",\n";
        }
      }
      output += "  }\n";
      return output;
    };

    return PovRay;

  })();

  module.exports = new Stl.PovRay();

}).call(this);
